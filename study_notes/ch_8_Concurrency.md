## Часть 8. Concurrency
Интерфейсы **Callable** и **Runnable**
Callable отличается от Runnable тем, что в Runnable метод run() не возвращает значение и не может генерировать исключения (только RuntimeExceptions).

`Callable`
```java
public interface Callable {
	V call() throws Exception;
}
```

`Runnable`
```java
public interface Runnable {  
  public abstract void run();  
}
```

**Callable** возвращает результат действий, которыев в будущем будут выполнены.

**Future** интерфейс описывает API для работы с задачами, результат которых мы планируем получить в будущем: методы получения результата, методы проверки статуса.

`Future`
```java
public interface Future<V> {  
  
 boolean cancel(boolean mayInterruptIfRunning);  
  
 boolean isCancelled();  
  
 boolean isDone();  
  
 V get(long timeout, TimeUnit unit)  
        throws InterruptedException, ExecutionException, TimeoutException;  
}
```

`FutureTask` - Реализация интерфейса Future.
Методы:
`V get()` - получение результата выполнения потока; !!!!!! **вызов метода блокирует дальнейшее выполнения кода до окончания вычислений** !!!!!!

`V get(long timeout, TimeUnit unit)` - получение результата до окончания до истечения указанного интервала времени; если в течение указанного времени вычисления не завершились, то вызывается исключение TimeoutException

`boolean cancel(boolean mayInterrupt)` - отмена выполнения задачи; если задача уже стартовала и параметр mayInterrupt равен true, то она прерывается, в противном случае, если вычисления еще не начаты, то они и не начнутся. При успешной отмене выполнения задачи метод возвращает значение true

`boolean isCancelled()` - метод возвращает true, если задача была отменена до ее нормального завершения

`boolean isDone()` - метод возвращает true, если выполнение задачи завершено, прервано или если в процессе ее выполнения возникло исключение


`ExecutorService`
**интерфейс**, который исполняет асинхронный код в одном или нескольких потоках. Создание инстанса ExecutorService'а делается либо вручную через конкретные имплементации (`ScheduledThreadPoolExecutor` или `ThreadPoolExecutor`), но проще будет использовать фабрики класса `Executors`. Например, если надо создать пул с 2мя потоками, то делается это так:

```java
	ExecutorService service = Executors.newFixedThreadPool(2);
```

Если требуется использовать кэширующий пул потоков, который создает потоки по мере необходимости, но переиспользует неактивные потоки (и подчищает потоки, которые были неактивные некоторое время), то это задается следующим образом:
```java
 	ExecutorService service = Executors.newCachedThreadPool();
```


`ExcecutorService`
Методы:
 ```java
 boolean awaitTermination(long timeout, TimeUnit unit)
 ```
Блокировка до тех пор, пока все задачи не завершат выполнение после запроса на завершение работы или пока не наступит тайм-аут или не будет прерван текущий поток, в зависимости от того, что произойдет раньше

```java
List<Future<T>> invokeAll (Collection<? extends Callable<T>> tasks)
```
Выполнение задач с возвращением списка задач с их статусом и результатами завершения

```java
List<Future<T>> invokeAll (Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
```
Выполнение задач с возвращением списка задач с их статусом и результатами завершения в течение заданного времени

```java
T invokeAny(Collection<? extends Callable<T>> tasks)
```
Выполнение задач с возвращением результата успешно выполненной задачи (т. е. без создания исключения), если таковые имеются

```java
T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
```
Выполнение задач в течение заданного времени с возвращением результата успешно выполненной задачи (т. е. без создания исключения), если таковые имеются

```java
boolean isShutdown()
```
Возвращает true, если исполнитель сервиса остановлен (shutdown)

```java
boolean isTerminated()
```
Возвращает true, если все задачи исполнителя сервиса завершены по команде остановки (shutdown)

```java
void **shutdown()**
```
Упорядоченное завершение работы, при котором ранее отправленные задачи выполняются, а новые задачи не принимаются

```java
List<Runnable> shutdownNow()
```
Остановка всех активно выполняемых задач, остановка обработки ожидающих задач, возвращение списка задач, ожидающих выполнения

```java
Future<T> submit(Callable<T> task)
Future<T> submit(Runnable task, T result);
Future<?> submit(Runnable task);
```
Принимает на выполнение `Callable` или `Runnable` таск, и возвращает объект `Future`

`Future` можно использовать с Runnable лямбда-выражениями, которые не имеют возвращаемого значения, но возвращаемое значение всегда равно null при завершении.

`Future<?> **submit**(Runnable task)`
Завершение выполнения задачи, возвращающей объект Future, представляющий данную задачу

`Future<T> submit(Runnable task, T result)`
Завершение выполнения задачи, возвращающей объект Future, представляющий данную задачу

-   `shutdown()`:
    Метод для завершения потоков внутри ExecutorService.
    ExecutorService не завершится немедленно, но он больше не будет принимать задачи на выполнение и как только все потоки закончат текущие таски, тогда ExecutorService выключится. Все задачи начатые в ExecutorService до вызова метода `shutdown` будут выполнены.

-   `shutdownNow()`:
    Если вы хотите выключить ExecutorService немедленно, вы можете вызвать `shutdownNow()` метод. Он предпримет попытку остановить все работающие сейчас таски, и пропустить принятые, но не начатые задачи. Не даёт гарантий о работе текущих процессов. Возможно они остановятся, а возможно будут выполняться до конца.


См также [Locks](Locks.md)
Интерфейс `Lock`
```java
public interface Lock {  
  void lock();  
  void lockInterruptibly() throws InterruptedException;  
  boolean tryLock();  
  boolean tryLock(long time, TimeUnit unit) throws InterruptedException;  
  void unlock();  
  Condition newCondition();  
}
```

Различия между `Lock` и `synchronized` блоком

Есть несколько различий между использованием синхронизированного блока и использованием API блокировки:

- Синхронизированный блок полностью содержится в методе - мы можем иметь операции lock () и unlock () API Lock в отдельных методах.
- Синхронизированный блок не поддерживает справедливость, любой поток может получить блокировку после освобождения, никакие предпочтения не могут быть указаны. Мы можем добиться справедливости в API Lock, указав свойство _fairness_. Он гарантирует, что самый длинный ожидающий поток получит доступ к блокировке.
- Поток блокируется, если он не может получить доступ к синхронизированному блоку. Lock API предоставляет метод tryLock(). Поток получает блокировку, только если она доступна и не удерживается каким-либо другим потоком. Это сокращает время блокировки потока, ожидающего блокировки.
- Поток, который находится в состоянии «ожидания» получения доступа к синхронизированному блоку, не может быть прерван. Lock API предоставляет метод lockInterruptibly(), который можно использовать для прерывания потока, когда он ожидает блокировки.

Перед экзаменом помните, что `Concurrent` классы упорядочивают доступ для чтения и записи таким образом, чтобы доступ к классу был согласован для всех потоков и процессов, а синхронизированные классы - нет.

### synchronized
Если блок кода помечен ключевым словом synchronized, это значит, что блок может выполняться только одним потоком одновременно.
Синхронизацию можно реализовать по-разному. Например, создать целый синхронизированный метод:

```java
public synchronized void doSomething() {

   //...логика метода
}
```

Или же написать блок кода, где синхронизация осуществляется **по какому-то объекту**:

```java
public class Main {

   private Object obj = new Object();

   public void doSomething() {

       //...какая-то логика, доступная для всех потоков

       synchronized (obj) {

           //логика, которая одновременно доступна только для одного потока
       }
   }
}
```

### Resource Stravation(нехватка ресурсов)
Это cостояние при котором одному активному потоку постоянно отказывают в доступе к общему ресурсу или блокируют. Их делят на несколько ситуаций

**LiveLock** - динамическая блокировки состояния процессов, задействованных в сценарии динамической блокировки, когда процессы зависят друг от друга и никогда не могут завершить свои задачи. **Потоки всё время активны.**

**DeadLock** - состояние, когда два потока бесконечно ждут друг друга, чтобы снять общие блокировки. **Потоки неактивны**

**Race Condition** - Состояние когда несколько потоков пытаются сделать запись в один ресурс. Когда работа системы или приложения зависит от того, в каком порядке выполняются части кода.

Сниппет `synchronized(X.class)` использует объект класса как монитор.

C  `synchronized(this)` блок кода будет защищён для инстанса.

`synchronized(X.class)` is used to make sure that there is exactly one Thread in the block. `synchronized(this)` ensures that there is exactly one thread per instance. If this makes the actual code in the block thread-safe depends on the implementation. If mutate only state of the instance `synchronized(this)` is enough

